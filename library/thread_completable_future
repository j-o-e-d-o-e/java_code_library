Thread->CompletableFuture

async

- provides methods for composing, combining and executing async computation-steps and error handling
- implements Future<T>, CompletionStage<T> (in java.util.concurrent)
- init
    - CompletableFuture()
    - CompletableFuture(Object r)
- static methods, e.g.
    - completedFuture(T val) returns completed CompletableFuture<T> containing val
    - failedFuture(Throwable ex) returns failed CompletableFuture<T> containing ex
    - runAsync(Runnable r) returns CompletableFuture<Void> that is completed async by r
    - supplyAsync(Supplier<T> s) returns CompletableFuture<T> that is completed async by s
    - allOf(CompletableFuture<?>... fs) returns CompletableFuture<Void> that is completed when all fs complete
- instance methods, e.g.
    - get() returns result T (triggers completion and waits/blocks for the result to finish)
    - complete(T val) sets value returned by get() to val if not already completed and returns boolean
    - thenApply(Function<T, R> func) applies func to this stage's result and returns CompletableFuture<R>
        - analogous to: Optional.map() and Stream.map()
    - thenAccept(Consumer<T> action) performs action on this and returns CompletableFuture<Void>
    - thenRun(Runnable r) performs action and returns CompletableFuture<Void>
    - thenCompose(Function<T, CompletionStage<R>> func) returns CompletableFuture<R> returned by func

SEE ALSO
    - baeldung.com/java-completablefuture

EXAMPLE
int[] op1 = {1, 2, 3};
int[] op2 = {4, 5, 6};
List<CompletableFuture<Integer>> ls1 = sumAsync(op1);
List<CompletableFuture<Integer>> ls2 = sumAsync(op2);
CompletableFuture<Void> all = CompletableFuture.allOf(Stream.concat(ls1.stream(), ls2.stream()).toArray(CompletableFuture[]::new));
try {
    all.get();
    Function<int[], String> join = ints -> Arrays.stream(ints).mapToObj(Integer::toString).collect(Collectors.joining(" + "));
    System.out.printf("%n%s = %2d", join.apply(op1), ls1.get(0).get());
    System.out.printf("%n%s = %2d", join.apply(op2), ls2.get(0).get());
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}

static List<CompletableFuture<Integer>> sumAsync(int[] ints) {
    List<CompletableFuture<Integer>> futures = new ArrayList<>();
    AtomicInteger res = new AtomicInteger();
    for (int i : ints) {
        futures.add(CompletableFuture.supplyAsync(() -> {
            System.out.printf("%-2d+%2d... ", res.getAndAdd(i), i);
            return res.get();
        }));
    }
    return futures;
}
// 0 + 1... 9 + 6... 4 + 5... 0 + 4... 3 + 3... 1 + 2... 
// 1 + 2 + 3 =  6
// 4 + 5 + 6 = 15
