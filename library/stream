Stream

api for sequences

- sequence of elems supporting sequential and parallel aggregate operations
(1) static methods of Stream
    - of(T... vals) returns stream with vals
    - empty() returns empty stream
    - concat(Stream<? extends T> a, Stream<? extends T> b) returns concatenation of a and b
    - iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next) returns ordered stream
        - seed: initial elem
        - hasNext: applied to each elem to determine when stream must terminate (optional)
            - if not given, returns infinite stream
        - next: applied to prev elem to produce a new elem
    - generate(Supplier<? extends T> s) returns infinite, unordered stream where each elem is generated by s        
    - builder() returns Stream.Builder<T> for a stream
- methods on Stream<T>-obj
(2) intermediate
    - map(Function<? super T, ? extends R> mapper) applies mapper to each elem and returns new stream
        - specializations for primitives: int, double, long, e.g.
            - mapToInt(ToIntFunction<? super T> mapper) returns IntStream
    - filter(Predicate<? super T> pred) returns stream consisting only of elems that match pred
    - skip(long n) discards the first n elems of this stream
    - limit(long n) discards all elems after nth elem
    - sorted(Comparator<? super T> comp) sorts according to comp and returns new stream
        - comp: optional; if not given, sorts by natural order
    - distinct() returns stream consisting of unique elems
    - flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) maps each elem to many and flattens new stream
        - mapper: applied to each elem and returns stream of new vals
        - specializations for primitives: int, double, long, e.g.
            - flatMapToInt(Function<? super T, ? extends IntStream> mapper)
    - mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper) maps each elem to many and flattens new stream
        - mapper accepts an elem and a consumer that accepts replacement elems
        - unlike flatMap(), avoids creating new Stream<T> instance for each elem
    - dropWhile(Predicate<? super T> pred) removes all elems that match pred until an elem does not match
        - from that point on, it takes all remaining elems
    - takeWhile(Predicate<? super T> pred) takes all elems that match pred until an elem does not match
        - from that point on, it removes all remaining elems
    - peek(Consumer<? super T> action) applies action on each elem and returns new stream
        - mainly for debugging purposes
(3) terminal
    - forEach(Consumer<? super T> action) performs action for each elem
    - forEachOrdered(Consumer<? super T> action) guarantees to maintain the order of this
    - reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
        - identity: initial val (optional)
        - accumulator: incorporates next elem into result
        - combiner: combines two vals; useful for parrallel execution (optional)
    - collect(Collector<? super T, A, R> c) returns result of mutable reduction using c
    - min(Comparator<? super T> comp) returns min according to c
    - max(Comparator<? super T> comp) returns max according to c
    - count() returns num of elems in this
    - findFirst() returns Optional<T> of 1st elem
    - findAny() is free to select any elem in this
    - toList() returns List<T> containing all elems
    - toArray() returns Object[]
(4) check (terminal)
    - allMatch(Predicate<? super T> pred) returns true if pred holds true for all elems 
    - anyMatch(Predicate<? super T> pred) returns true if pred holds true for any elem
    - noneMatch(Predicate<? super T> pred) returns true if pred is false for all elems 

EXAMPLE
(1)
Stream<Integer> s1 = Stream.of(1, 2, 3);
Stream<Integer> s2 = Stream.iterate(4, i -> i < 7, i -> i + 1);
Stream<Integer> s = Stream.concat(s1, s2);
s.forEach(i -> System.out.printf("%d ", i));    // 1 2 3 4 5 6

(2)
DoubleStream sd = Stream.of(1, 2).mapToDouble(i -> i + i / 10d);
sd.forEach(d -> System.out.printf("%.2f ", d)); // 1.10 2.20

Stream<String> a = Stream.of("a", "b");
List<String> lsa = a.flatMap(str -> Stream.of(str + 1, str + "2"))
        .toList();  // lsa = [a1, a2, b1, b2]

Stream<String> b = Stream.of("a", "b");
List<String> lsb = b.<String>mapMulti((str, c) -> {
    c.accept(str + 1);
    c.accept(str + 2);
}).toList();        // lsb = [a1, a2, b1, b2]

Stream<Integer> si = Stream.of(1, 2, 3);
List<Integer> lsi = si.dropWhile(n -> n % 2 == 1).toList(); // [2, 3]

(3)
Stream<Integer> s = Stream.of(3, 2, 1);
Integer i = s.reduce(601, (res, elem) -> res + elem * 10 + 2); // i == 667
